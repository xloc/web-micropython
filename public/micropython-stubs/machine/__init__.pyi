"""
MicroPython builtin module: machine

This is a minimal set of type stubs intended to make common
APIs available for IntelliSense, hover docs and diagnostics.

Note: Signatures vary across ports/boards; these stubs focus on
the most widely used parameters and return types.
"""

from typing import Optional, Callable, Any

# --- Constants (subset) ---
DEEPSLEEP: int
PWRON_RESET: int
HARD_RESET: int
WDT_RESET: int
DEEPSLEEP_RESET: int
SOFT_RESET: int


class Pin:
    """General-purpose I/O pin"""

    IN: int
    OUT: int
    OPEN_DRAIN: int
    PULL_UP: int
    PULL_DOWN: int
    IRQ_FALLING: int
    IRQ_RISING: int


    def __init__(self, id: int | str, mode: int = ..., pull: Optional[int] = ..., value: Optional[int] = ...) -> None: ...
    def init(self, mode: int = ..., pull: Optional[int] = ..., value: Optional[int] = ...) -> None: ...
    def value(self, x: Optional[int] = ...) -> int: ...
    def on(self) -> None: ...
    def off(self) -> None: ...
    def irq(self, handler: Optional[Callable[[Any], None]] = ..., trigger: int = ..., hard: bool = ...) -> Any: ...


class I2C:
    """I2C bus interface (hardware or software)"""

    def __init__(self, id: int = ..., *, scl: Any = ..., sda: Any = ..., freq: int = ...) -> None: ...
    def readfrom(self, addr: int, nbytes: int, stop: bool = ...) -> bytes: ...
    def readfrom_into(self, addr: int, buf: bytearray, stop: bool = ...) -> None: ...
    def writeto(self, addr: int, buf: bytes | bytearray, stop: bool = ...) -> int: ...
    def scan(self) -> list[int]: ...


class SPI:
    """SPI bus interface (hardware or software)"""

    def __init__(self, id: int = ..., baudrate: int = ..., polarity: int = ..., phase: int = ..., bits: int = ..., firstbit: int = ..., sck: Any = ..., mosi: Any = ..., miso: Any = ...) -> None: ...
    def read(self, nbytes: int, write: int = ...) -> bytes: ...
    def readinto(self, buf: bytearray, write: int = ...) -> None: ...
    def write(self, buf: bytes | bytearray) -> None: ...
    def write_readinto(self, write_buf: bytes | bytearray, read_buf: bytearray) -> None: ...


class UART:
    """UART interface"""

    def __init__(self, id: int, baudrate: int = ..., bits: int = ..., parity: Optional[int] = ..., stop: int = ..., tx: Any = ..., rx: Any = ...) -> None: ...
    def init(self, baudrate: int = ..., bits: int = ..., parity: Optional[int] = ..., stop: int = ...) -> None: ...
    def read(self, nbytes: Optional[int] = ...) -> Optional[bytes]: ...
    def readline(self) -> Optional[bytes]: ...
    def readinto(self, buf: bytearray, nbytes: Optional[int] = ...) -> Optional[int]: ...
    def write(self, buf: bytes | bytearray) -> int: ...
    def any(self) -> int: ...


class PWM:
    """Pulse-width modulation on a Pin"""

    def __init__(self, pin: Pin, freq: int = ..., duty_u16: int = ...) -> None: ...
    def freq(self, freq: Optional[int] = ...) -> int: ...
    def duty_u16(self, value: Optional[int] = ...) -> int: ...
    def deinit(self) -> None: ...


class Timer:
    """Timer; periodic or one-shot callbacks"""

    PERIODIC: int
    ONE_SHOT: int
    def __init__(self, id: int = ...) -> None: ...
    def init(self, *, mode: int = ..., period: int = ..., callback: Optional[Callable[[Any], None]] = ...) -> None: ...
    def deinit(self) -> None: ...


class ADC:
    """Analog-to-digital converter"""

    def __init__(self, pin: Any | int) -> None: ...
    def read_u16(self) -> int: ...


class SoftI2C(I2C): ...
class SoftSPI(SPI): ...


class RTC:
    def datetime(self, datetime: Optional[tuple] = ...) -> tuple: ...


class WDT:
    def __init__(self, timeout: int) -> None: ...
    def feed(self) -> None: ...


def reset() -> None: ...
def reset_cause() -> int: ...
def freq() -> int | tuple[int, ...]: ...
def idle() -> None: ...
def lightsleep(time_ms: Optional[int] = ...) -> None: ...
def deepsleep(time_ms: Optional[int] = ...) -> None: ...
def unique_id() -> bytes: ...

