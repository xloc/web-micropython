"""
machine — functions related to the hardware

APIs sourced from micropython-master/docs/library/machine.rst and
associated class reference files (Pin, I2C, SPI, UART, PWM, Timer, ADC, RTC, WDT).
Docstrings are adapted from the official documentation.
"""

from typing import Any, Iterable, Optional, overload

# Memory access objects
mem8: Any
mem16: Any
mem32: Any

# Power/IRQ/reset constants (availability is port-dependent)
IDLE: int
SLEEP: int
DEEPSLEEP: int
PWRON_RESET: int
HARD_RESET: int
WDT_RESET: int
DEEPSLEEP_RESET: int
SOFT_RESET: int
WLAN_WAKE: int
PIN_WAKE: int
RTC_WAKE: int

def reset() -> None:
    """Hard reset the device, similar to pressing the external RESET button."""
    ...

def soft_reset() -> None:
    """Soft reset the interpreter, clearing Python state and heap."""
    ...

def reset_cause() -> int:
    """Get the reset cause; see constants like PWRON_RESET, HARD_RESET, etc."""
    ...

def bootloader(value: Optional[int] = ...) -> None:
    """
    Enter the device bootloader. Some ports accept an optional value to select
    a specific bootloader mode.
    """
    ...

def disable_irq() -> int:
    """Disable interrupts and return previous IRQ state (opaque value)."""
    ...

def enable_irq(state: int) -> None:
    """Re-enable interrupts using the state value returned by disable_irq()."""
    ...

@overload
def freq() -> int: ...
@overload
def freq(hz: int) -> None: ...

def idle() -> None:
    """
    Gate the CPU clock to reduce power. Peripherals keep running. Execution
    resumes on interrupt or after a short delay.
    """
    ...

def sleep() -> None:
    """Deprecated. Use lightsleep() with no arguments instead."""
    ...

def lightsleep(time_ms: Optional[int] = ...) -> None:
    """
    Enter a light sleep with full RAM/state retention. If time_ms is given,
    sleep up to that duration; otherwise sleep indefinitely until a wake event.
    """
    ...

def deepsleep(time_ms: Optional[int] = ...) -> None:
    """
    Enter a deep sleep with minimal retention. On wake, execution restarts
    like a reset. reset_cause() will be DEEPSLEEP_RESET.
    """
    ...

def wake_reason() -> int:
    """Get the wake reason; see e.g. WLAN_WAKE, PIN_WAKE, RTC_WAKE."""
    ...

def unique_id() -> bytes:
    """Return a bytes object with a unique identifier for the board/SoC."""
    ...

def time_pulse_us(pin: Any, pulse_level: int, timeout_us: int = 1000000, /) -> int:
    """
    Time a pulse on pin and return the duration in microseconds. Returns -2 on
    timeout waiting for the level to start, and -1 on timeout during measure.
    """
    ...

def bitstream(pin: Any, encoding: int, timing: tuple[int, int, int, int], data: bytes | bytearray, /) -> None:
    """
    Transmit data by bit-banging pin using the given encoding and timing. See
    docs for supported encodings and timing tuple format.
    """
    ...

def rng() -> int:
    """Return a 24-bit software-generated random number. Availability: WiPy."""
    ...


class Pin:
    """
    Pin — control I/O pins

    Control GPIO pins for digital input/output, pull resistors, and IRQs.
    """

    # Modes
    IN: int
    OUT: int
    OPEN_DRAIN: int
    ALT: int
    ALT_OPEN_DRAIN: int
    ANALOG: int

    # Pull
    PULL_UP: int
    PULL_DOWN: int

    # Drive strength (port dependent)
    DRIVE_0: int
    DRIVE_1: int

    # IRQ triggers
    IRQ_FALLING: int
    IRQ_RISING: int
    IRQ_LOW_LEVEL: int
    IRQ_HIGH_LEVEL: int

    def __init__(self, id: Any, mode: int = -1, pull: int = -1, *, value: Optional[int] = None, drive: int = 0, alt: int = -1) -> None: ...
    def init(self, mode: int = -1, pull: int = -1, *, value: Optional[int] = None, drive: int = 0, alt: int = -1) -> None: ...
    def value(self, x: Optional[int] = ...) -> int: ...
    def __call__(self, x: Optional[int] = ...) -> int: ...
    def on(self) -> None: ...
    def off(self) -> None: ...
    def irq(self, handler: Optional[Any] = ..., trigger: int = IRQ_FALLING | IRQ_RISING, *, priority: int = 1, wake: Optional[int] = None, hard: bool = False) -> Any: ...


class I2C:
    """
    I2C — a two-wire serial protocol (controller)

    Supports hardware I2C. See SoftI2C for bit-banged I2C.
    """

    def __init__(self, id: Any = ..., *, scl: Any, sda: Any, freq: int = 400000, timeout: int = 50000) -> None: ...
    def init(self, scl: Any, sda: Any, *, freq: int = 400000) -> None: ...
    def deinit(self) -> None: ...
    def scan(self) -> list[int]: ...
    # Standard operations
    def readfrom(self, addr: int, nbytes: int, stop: bool = True, /) -> bytes: ...
    def readfrom_into(self, addr: int, buf: bytearray, stop: bool = True, /) -> None: ...
    def writeto(self, addr: int, buf: bytes | bytearray, stop: bool = True, /) -> int: ...
    def writevto(self, addr: int, vector: Iterable[bytes | bytearray], stop: bool = True, /) -> int: ...
    # Memory operations
    def readfrom_mem(self, addr: int, memaddr: int, nbytes: int, *, addrsize: int = 8) -> bytes: ...
    def readfrom_mem_into(self, addr: int, memaddr: int, buf: bytearray, *, addrsize: int = 8) -> None: ...
    def writeto_mem(self, addr: int, memaddr: int, buf: bytes | bytearray, *, addrsize: int = 8) -> None: ...


class SoftI2C(I2C):
    """Software I2C (bit-banged). Same API as I2C, with extra primitives."""
    def __init__(self, scl: Any, sda: Any, *, freq: int = 400000, timeout: int = 50000) -> None: ...
    # Primitives available on SoftI2C
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def readinto(self, buf: bytearray, nack: bool = True, /) -> None: ...
    def write(self, buf: bytes | bytearray) -> int: ...


class SPI:
    """
    SPI — Serial Peripheral Interface (controller)

    Supports hardware SPI. See SoftSPI for bit-banged SPI.
    """

    # Bit order constants
    MSB: int
    LSB: int

    def __init__(self, id: Any, /, *args: Any, **kwargs: Any) -> None: ...
    def init(self, baudrate: int = 1000000, *, polarity: int = 0, phase: int = 0, bits: int = 8, firstbit: int = MSB, sck: Optional[Any] = None, mosi: Optional[Any] = None, miso: Optional[Any] = None, pins: Any = ...) -> None: ...
    def deinit(self) -> None: ...
    def read(self, nbytes: int, write: int = 0x00) -> bytes: ...
    def readinto(self, buf: bytearray, write: int = 0x00) -> None: ...
    def write(self, buf: bytes | bytearray) -> None: ...
    def write_readinto(self, write_buf: bytes | bytearray, read_buf: bytearray) -> None: ...


class SoftSPI(SPI):
    """Software SPI (bit-banged)."""
    def __init__(self, baudrate: int = 500000, *, polarity: int = 0, phase: int = 0, bits: int = 8, firstbit: int = SPI.MSB, sck: Optional[Any] = None, mosi: Optional[Any] = None, miso: Optional[Any] = None) -> None: ...


class UART:
    """
    UART — duplex serial communication bus
    """

    # Inversion and flow constants
    INV_TX: int
    INV_RX: int
    RTS: int
    CTS: int
    # IRQ trigger constants
    IRQ_RXIDLE: int
    IRQ_RX: int
    IRQ_TXIDLE: int
    IRQ_BREAK: int

    def __init__(self, id: Any, /, *args: Any, **kwargs: Any) -> None: ...
    def init(self, baudrate: int = 9600, bits: int = 8, parity: Optional[int] = None, stop: int = 1, *, tx: Optional[Any] = None, rx: Optional[Any] = None, rts: Optional[Any] = None, cts: Optional[Any] = None, txbuf: Optional[int] = None, rxbuf: Optional[int] = None, timeout: Optional[int] = None, timeout_char: Optional[int] = None, invert: Optional[int] = None, flow: Optional[int] = None, pins: Any = ...) -> None: ...
    def deinit(self) -> None: ...
    def any(self) -> int: ...
    def read(self, nbytes: Optional[int] = ...) -> Optional[bytes]: ...
    def readinto(self, buf: bytearray, nbytes: Optional[int] = ...) -> Optional[int]: ...
    def readline(self) -> Optional[bytes]: ...
    def write(self, buf: bytes | bytearray) -> Optional[int]: ...
    def sendbreak(self) -> None: ...
    def flush(self) -> None: ...
    def txdone(self) -> bool: ...
    def irq(self, handler: Optional[Any] = ..., trigger: int = 0, hard: bool = False) -> Any: ...


class PWM:
    """PWM — pulse width modulation output."""
    def __init__(self, dest: Any, *, freq: Optional[int] = None, duty_u16: Optional[int] = None, duty_ns: Optional[int] = None, invert: bool = False) -> None: ...
    def init(self, *, freq: Optional[int] = None, duty_u16: Optional[int] = None, duty_ns: Optional[int] = None) -> None: ...
    def deinit(self) -> None: ...
    def freq(self, value: Optional[int] = ...) -> int | None: ...
    def duty_u16(self, value: Optional[int] = ...) -> int | None: ...
    def duty_ns(self, value: Optional[int] = ...) -> int | None: ...


class Timer:
    """Timer — control hardware timers for periodic or one-shot callbacks."""
    ONE_SHOT: int
    PERIODIC: int
    def __init__(self, id: Any, /, *args: Any, **kwargs: Any) -> None: ...
    def init(self, *, mode: int = PERIODIC, freq: int = -1, period: int = -1, callback: Optional[Any] = None, hard: bool = True) -> None: ...
    def deinit(self) -> None: ...


class ADC:
    """ADC — analog to digital conversion (single channel)."""
    def __init__(self, id: Any, /, *, sample_ns: Optional[int] = None, atten: Optional[Any] = None) -> None: ...
    def init(self, *, sample_ns: Optional[int] = None, atten: Optional[Any] = None) -> None: ...
    def block(self) -> Any: ...
    def read_u16(self) -> int: ...
    def read_uv(self) -> int: ...


class RTC:
    """RTC — real time clock."""
    ALARM0: int
    def __init__(self, id: int = 0, /, *args: Any, **kwargs: Any) -> None: ...
    def datetime(self, datetimetuple: Optional[tuple[int, int, int, int, int, int, int, int]] = ...) -> tuple[int, int, int, int, int, int, int, int]: ...
    def init(self, datetime: tuple[int, int, int, int, int, int, int, Any]) -> None: ...
    def now(self) -> tuple[int, int, int, int, int, int, int, int]: ...
    def deinit(self) -> None: ...
    def alarm(self, id: int, time: Any, *, repeat: bool = False) -> None: ...
    def alarm_left(self, alarm_id: int = 0) -> int: ...
    def alarm_cancel(self, alarm_id: int = 0) -> None: ...
    def irq(self, *, trigger: int, handler: Optional[Any] = None, wake: int = IDLE) -> Any: ...
    def memory(self, data: Optional[bytes | bytearray | memoryview] = ...) -> bytes | None: ...


class WDT:
    """WDT — watchdog timer. Restart system if not fed before timeout."""
    def __init__(self, id: int = 0, timeout: int = 5000) -> None: ...
    def feed(self) -> None: ...
